

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>equadratures.polyint &mdash; Effective Quadratures v7.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/logo.png"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../_documentation/index.html" class="icon icon-home"> Effective Quadratures
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../_documentation/introduction.html">Effective Quadratures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_documentation/modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_documentation/tutorials.html">Quick start guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_documentation/contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../_documentation/index.html">Effective Quadratures</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../_documentation/index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>equadratures.polyint</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for equadratures.polyint</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Operations involving multivariate polynomials (without gradients) via numerical quadrature.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">parameter</span> <span class="k">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">basis</span> <span class="k">import</span> <span class="n">Basis</span>
<span class="kn">from</span> <span class="nn">basis</span> <span class="k">import</span> <span class="n">sparse_grid_basis</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="k">import</span> <span class="n">find_repeated_elements</span><span class="p">,</span> <span class="n">evalfunction</span>
<span class="kn">from</span> <span class="nn">poly</span> <span class="k">import</span> <span class="n">Poly</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="Polyint"><a class="viewcode-back" href="../../_documentation/polyint.html#equadratures.polyint.Polyint">[docs]</a><span class="k">class</span> <span class="nc">Polyint</span><span class="p">(</span><span class="n">Poly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class defines a Polyint (polynomial via integration) object</span>

<span class="sd">    :param Parameter parameters:</span>
<span class="sd">        A list of parameters.</span>
<span class="sd">    :param Basis basis:</span>
<span class="sd">        A basis selected for the multivariate polynomial.</span>
<span class="sd">    :param string sampling:</span>
<span class="sd">        The sampling technique. Choose from: &#39;tensor grid quadrature&#39; (default), &#39;sparse grid quadrature&#39;, &#39;effectively subsampled quadrature&#39;, &#39;Christoffel subsamples&#39;, &#39;Induced subsamples&#39; and &#39;randomized quadrature&#39;.</span>
<span class="sd">    :param callable fun:</span>
<span class="sd">        Instead of specifying the output training points, the user can also provide a callable function, which will be evaluated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__computeQuadraturePoints</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__computeQuadraturePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">dummy_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">1.0</span>

        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;sparse grid&#39;</span><span class="p">:</span>
            <span class="n">__</span> <span class="p">,</span> <span class="n">indexset</span><span class="p">,</span> <span class="n">evaled_pts</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">getSparsePseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dummy_function</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tensor grid&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tensor&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;univariate&#39;</span><span class="p">):</span>
            <span class="n">__</span> <span class="p">,</span> <span class="n">indexset</span><span class="p">,</span> <span class="n">evaled_pts</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">getPseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dummy_function</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">indexset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">=</span> <span class="n">indexset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadraturePoints</span> <span class="o">=</span> <span class="n">evaled_pts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadratureWeights</span> <span class="o">=</span> <span class="n">weights</span>

<div class="viewcode-block" id="Polyint.computeCoefficients"><a class="viewcode-back" href="../../_documentation/polyint.html#equadratures.polyint.Polyint.computeCoefficients">[docs]</a>    <span class="k">def</span> <span class="nf">computeCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns multivariate orthonormal polynomial coefficients.</span>

<span class="sd">        :param Polyint self: </span>
<span class="sd">            An instance of the Polyint class</span>
<span class="sd">        :param: callable function:</span>
<span class="sd">            The function that needs to be approximated (or interpolated)</span>
<span class="sd">        :return: coefficients: </span>
<span class="sd">            The pseudospectral coefficients</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        :return: indexset: </span>
<span class="sd">            The indices used for the pseudospectral computation</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        :return: evaled_pts: </span>
<span class="sd">            The points at which the function was evaluated</span>
<span class="sd">        :rtype: ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Method to compute the coefficients</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;sparse grid&#39;</span><span class="p">:</span>
            <span class="n">coefficients</span><span class="p">,</span> <span class="n">indexset</span><span class="p">,</span> <span class="n">evaled_pts</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">getSparsePseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tensor grid&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tensor&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;univariate&#39;</span><span class="p">):</span>
            <span class="n">coefficients</span><span class="p">,</span> <span class="n">indexset</span><span class="p">,</span> <span class="n">evaled_pts</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">getPseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">indexset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">=</span> <span class="n">indexset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadraturePoints</span> <span class="o">=</span> <span class="n">evaled_pts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadratureWeights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setCoefficients__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setQuadrature__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadraturePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratureWeights</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setBasis__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span></div></div>


<span class="c1">#--------------------------------------------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#  PRIVATE FUNCTIONS!</span>
<span class="c1">#</span>
<span class="c1">#--------------------------------------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">getPseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">override_orders</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">override_orders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pts</span><span class="p">,</span> <span class="n">wts</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getTensorQuadratureRule</span><span class="p">()</span>
        <span class="n">tensor_elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span>
        <span class="n">P</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getPolynomial</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pts</span><span class="p">,</span> <span class="n">wts</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getTensorQuadratureRule</span><span class="p">(</span><span class="n">override_orders</span><span class="p">)</span>
        <span class="n">tensor_basis</span> <span class="o">=</span> <span class="n">Basis</span><span class="p">(</span><span class="s1">&#39;Tensor grid&#39;</span><span class="p">,</span> <span class="n">override_orders</span><span class="p">)</span>
        <span class="n">tensor_elements</span> <span class="o">=</span> <span class="n">tensor_basis</span><span class="o">.</span><span class="n">elements</span>
        <span class="n">P</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Polyint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getPolynomial</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">tensor_elements</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wts</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wts</span><span class="p">)))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">evalfunction</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">pts</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">function</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">W</span>  <span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">tensor_elements</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">wts</span>

<span class="k">def</span> <span class="nf">getSparsePseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>

    <span class="c1"># INPUTS</span>
    <span class="n">stackOfParameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">indexSets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stackOfParameters</span><span class="p">)</span>
    <span class="n">sparse_indices</span><span class="p">,</span> <span class="n">sparse_factors</span><span class="p">,</span> <span class="n">not_used</span> <span class="o">=</span> <span class="n">sparse_grid_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">growth_rule</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_indices</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># For storage we use dictionaries</span>
    <span class="n">individual_tensor_coefficients</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">individual_tensor_indices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">points_store</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">weights_store</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">rows</span><span class="p">):</span>
        <span class="n">orders</span> <span class="o">=</span> <span class="n">sparse_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> 
        <span class="n">K</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">points</span> <span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">getPseudospectralCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">orders</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">individual_tensor_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">individual_tensor_coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">K</span>
        <span class="n">points_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
        <span class="n">weights_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        
    <span class="n">sum_indices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
    <span class="n">store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">points_saved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>
    <span class="n">weights_saved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">))</span>

    <span class="n">sum_indices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
    <span class="n">store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">points_saved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>
    <span class="n">weights_saved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">))</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
             <span class="n">store</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">individual_tensor_coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
             <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                 <span class="n">store</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">individual_tensor_indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                 <span class="n">points_saved</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_store</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
             <span class="n">weights_saved</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_store</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
             <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># Now we use a while loop to iteratively delete the repeated elements while summing up the</span>
    <span class="c1"># coefficients!</span>
    <span class="n">index_to_pick</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>

    <span class="n">final_store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">while</span><span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>

        <span class="c1"># find the repeated indices</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="n">find_repeated_elements</span><span class="p">(</span><span class="n">index_to_pick</span><span class="p">,</span> <span class="n">store</span><span class="p">)</span>
        <span class="n">coefficient_value</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Sum up all the coefficient values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep</span><span class="p">)):</span>
            <span class="n">actual_index</span> <span class="o">=</span> <span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">coefficient_value</span> <span class="o">=</span> <span class="n">coefficient_value</span> <span class="o">+</span> <span class="n">store</span><span class="p">[</span><span class="n">actual_index</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Store into a new array</span>
        <span class="n">final_store</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefficient_value</span>
        <span class="n">final_store</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="mi">1</span><span class="p">::]</span> <span class="o">=</span> <span class="n">store</span><span class="p">[</span><span class="n">index_to_pick</span><span class="p">,</span> <span class="mi">1</span><span class="p">::]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Delete index from store</span>
        <span class="n">store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># How many entries remain in store?</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">indices_to_delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">sum_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">final_store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">final_store</span><span class="p">,</span> <span class="n">indices_to_delete</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Now split final store into coefficients and their index sets!</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_store</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_store</span><span class="p">)):</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_store</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Splitting final_store to get the indices!</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">final_store</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::]</span>

    <span class="c1"># Now just double check to make sure they are all integers</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>

    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points_saved</span><span class="p">,</span> <span class="n">weights_saved</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    stackOfParameters = self.parameters</span>
<span class="sd">    dimensions = len(stackOfParameters)</span>
<span class="sd">    q0 = [1.0]</span>
<span class="sd">    Q = []</span>
<span class="sd">    orders = []</span>
<span class="sd">    # If additional orders are provided, then use those!</span>
<span class="sd">    if override_orders is None:</span>
<span class="sd">        for i in range(0, dimensions):</span>
<span class="sd">            orders.append(stackOfParameters[i].order)</span>
<span class="sd">            Qmatrix = stackOfParameters[i].getJacobiEigenvectors()</span>
<span class="sd">            Q.append(Qmatrix)</span>

<span class="sd">            if orders[i] == 1:</span>
<span class="sd">                q0 = np.kron(q0, Qmatrix)</span>
<span class="sd">            else:</span>
<span class="sd">                q0 = np.kron(q0, Qmatrix[0,:])</span>

<span class="sd">    else:</span>
<span class="sd">        for i in range(0, dimensions):</span>
<span class="sd">            orders.append(override_orders[i])</span>
<span class="sd">            Qmatrix = stackOfParameters[i].getJacobiEigenvectors(orders[i]+1)</span>
<span class="sd">            Q.append(Qmatrix)</span>

<span class="sd">            if orders[i] + 1 == 1:</span>
<span class="sd">                q0 = np.kron(q0, Qmatrix)</span>
<span class="sd">            else:</span>
<span class="sd">                q0 = np.kron(q0, Qmatrix[0,:])</span>

<span class="sd">    # Compute multivariate Gauss points and weights!</span>
<span class="sd">    if override_orders is None:</span>
<span class="sd">        p, w = self.getTensorQuadratureRule()</span>
<span class="sd">    else:</span>
<span class="sd">        p, w = self.getTensorQuadratureRule(override_orders)</span>

<span class="sd">    # Evaluate the first point to get the size of the system</span>
<span class="sd">    fun_value_first_point = function(p[0,:])</span>
<span class="sd">    u0 =  q0[0,0] * fun_value_first_point</span>
<span class="sd">    N = 1</span>
<span class="sd">    orders_plus_one = [x+1 for x in orders]</span>
<span class="sd">    gn = int(np.prod(orders_plus_one))</span>
<span class="sd">    Uc = np.zeros((N, gn))</span>
<span class="sd">    Uc[0,0] = u0</span>
<span class="sd">    function_values = np.zeros((1,gn))</span>
<span class="sd">    for i in range(0, gn):</span>
<span class="sd">        function_values[0,i] = function(p[i,:])</span>

<span class="sd">    # Now we evaluate the solution at all the points</span>
<span class="sd">    for j in range(1, gn): # 0</span>
<span class="sd">        Uc[0,j]  = q0[0,j] * function_values[0,j]</span>
<span class="sd">    basis = Basis(&#39;Tensor grid&#39;,  orders)</span>
<span class="sd">    tensor_set = basis.elements</span>

<span class="sd">    values = np.sum(tensor_set, 1)</span>
<span class="sd">    g = np.argsort(values)</span>
<span class="sd">    new_basis = tensor_set[g,:]</span>

<span class="sd">    # Now we use kronmult</span>
<span class="sd">    K = efficient_kron_mult(Q, Uc)</span>
<span class="sd">    K[0,:] = K[0,g]</span>
<span class="sd">    F = function_values</span>
<span class="sd">    K = np.column_stack(K)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def getSparsePseudospectralCoefficients(self, function):</span>

<span class="sd">    # INPUTS</span>
<span class="sd">    stackOfParameters = self.parameters</span>
<span class="sd">    indexSets = self.basis</span>
<span class="sd">    dimensions = len(stackOfParameters)</span>
<span class="sd">    sparse_indices, sparse_factors, not_used = sparse_grid_basis(self.basis.level, self.basis.growth_rule, self.dimensions)</span>
<span class="sd">    rows = len(sparse_indices)</span>
<span class="sd">    cols = len(sparse_indices[0])</span>

<span class="sd">    # For storage we use dictionaries</span>
<span class="sd">    individual_tensor_coefficients = {}</span>
<span class="sd">    individual_tensor_indices = {}</span>
<span class="sd">    points_store = {}</span>
<span class="sd">    weights_store = {}</span>
<span class="sd">    indices = np.zeros((rows))</span>

<span class="sd">    for i in range(0,rows):</span>
<span class="sd">        orders = sparse_indices[i,:] </span>
<span class="sd">        K, I, points , weights = getPseudospectralCoefficients(self, function, orders)</span>
<span class="sd">        individual_tensor_indices[i] = I</span>
<span class="sd">        individual_tensor_coefficients[i] =  K</span>
<span class="sd">        points_store[i] = points</span>
<span class="sd">        weights_store[i] = weights</span>
<span class="sd">        indices[i] = len(weights)</span>

<span class="sd">    sum_indices = int(np.sum(indices)) </span>
<span class="sd">    store = np.zeros((sum_indices, dimensions+1))</span>
<span class="sd">    points_saved = np.zeros((sum_indices, dimensions))</span>
<span class="sd">    weights_saved = np.zeros((sum_indices))</span>
<span class="sd">    counter = int(0)</span>
<span class="sd">    #print sum_indices </span>
<span class="sd">    #print &#39;******&#39;</span>
<span class="sd">    for i in range(0,rows):</span>
<span class="sd">        #print points_store[i]</span>
<span class="sd">        #print &#39;~~~~~~~~~&#39;</span>
<span class="sd">        #print indices[i]</span>
<span class="sd">        for j in range(0, int(indices[i])):</span>
<span class="sd">             store[counter,0] = sparse_factors[i] * individual_tensor_coefficients[i][j]</span>
<span class="sd">             for d in range(0, dimensions):</span>
<span class="sd">                 store[counter,d+1] = individual_tensor_indices[i][j, d]</span>
<span class="sd">                 points_saved[counter,d] = points_store[i][j, d]</span>
<span class="sd">             weights_saved[counter] = weights_store[i][j]</span>
<span class="sd">             counter = counter + 1</span>

<span class="sd">    # Now we use a while loop to iteratively delete the repeated elements while summing up the</span>
<span class="sd">    # coefficients!</span>
<span class="sd">    #print points_saved, weights_saved, store</span>
<span class="sd">    #print &#39;**********&#39;</span>
<span class="sd">    index_to_pick = 0</span>
<span class="sd">    flag = 1</span>
<span class="sd">    counter = 0</span>

<span class="sd">    rows = len(store)</span>

<span class="sd">    final_store = np.zeros((sum_indices, dimensions + 1))</span>
<span class="sd">    while(flag != 0):</span>

<span class="sd">        # find the repeated indices</span>
<span class="sd">        rep = find_repeated_elements(index_to_pick, store)</span>
<span class="sd">        print rep</span>
<span class="sd">        coefficient_value = 0.0</span>

<span class="sd">        # Sum up all the coefficient values</span>
<span class="sd">        for i in range(0, len(rep)):</span>
<span class="sd">            actual_index = rep[i]</span>
<span class="sd">            coefficient_value = coefficient_value + store[actual_index,0]</span>
<span class="sd">        print coefficient_value</span>
<span class="sd">        # Store into a new array</span>
<span class="sd">        final_store[counter,0] = coefficient_value</span>
<span class="sd">        final_store[counter,1::] = store[index_to_pick, 1::]</span>
<span class="sd">        counter = counter + 1</span>

<span class="sd">        # Delete index from store</span>
<span class="sd">        store = np.delete(store, rep, axis=0)</span>
<span class="sd">        #print final_store</span>
<span class="sd">        #print &#39;************&#39;</span>
<span class="sd">        # How many entries remain in store?</span>
<span class="sd">        rows = len(store)</span>
<span class="sd">        if rows == 0:</span>
<span class="sd">            flag = 0</span>

<span class="sd">    indices_to_delete = np.arange(counter, sum_indices, 1)</span>
<span class="sd">    final_store = np.delete(final_store, indices_to_delete, axis=0)</span>

<span class="sd">    # Now split final store into coefficients and their index sets!</span>
<span class="sd">    coefficients = np.zeros((1, len(final_store)))</span>
<span class="sd">    for i in range(0, len(final_store)):</span>
<span class="sd">        coefficients[0,i] = final_store[i,0]</span>

<span class="sd">    # Splitting final_store to get the indices!</span>
<span class="sd">    indices = final_store[:,1::]</span>

<span class="sd">    # Now just double check to make sure they are all integers</span>
<span class="sd">    for i in range(0, len(indices)):</span>
<span class="sd">        for j in range(0, dimensions):</span>
<span class="sd">            indices[i,j] = int(indices[i,j])</span>

<span class="sd">    K = np.column_stack(coefficients)</span>
<span class="sd">    return K, indices, points_saved, weights_saved</span>
<span class="sd">def efficient_kron_mult(Q, Uc):</span>
<span class="sd">    N = len(Q)</span>
<span class="sd">    n = np.zeros((N,1))</span>
<span class="sd">    nright = 1</span>
<span class="sd">    nleft = 1</span>
<span class="sd">    for i in range(0,N-1):</span>
<span class="sd">        rows_of_Q = len(Q[i])</span>
<span class="sd">        n[i,0] = rows_of_Q</span>
<span class="sd">        nleft = nleft * n[i,0]</span>

<span class="sd">    nleft = int(nleft)</span>
<span class="sd">    n[N-1,0] = len(Q[N-1]) # rows of Q[N]</span>

<span class="sd">    for i in range(N-1, -1, -1):</span>
<span class="sd">        base = 0</span>
<span class="sd">        jump = n[i,0] * nright</span>
<span class="sd">        for k in range(0, nleft):</span>
<span class="sd">            for j in range(0, nright):</span>
<span class="sd">                index1 = base + j</span>
<span class="sd">                index2 = int( base + j + nright * (n[i] - 1) )</span>
<span class="sd">                indices_required = np.arange(int( index1 ), int( index2 + 1 ), int( nright ) )</span>
<span class="sd">                small_Uc = np.mat(Uc[:, indices_required])</span>
<span class="sd">                temp = np.dot(Q[i] , small_Uc.T )</span>
<span class="sd">                temp_transpose = temp.T</span>
<span class="sd">                Uc[:, indices_required] = temp_transpose</span>
<span class="sd">            base = base + jump</span>
<span class="sd">        temp_val = np.max([i, 0]) - 1</span>
<span class="sd">        nleft = int(nleft/(1.0 * n[temp_val,0] ) )</span>
<span class="sd">        nright = int(nright * n[i,0])</span>

<span class="sd">    return Uc</span>
<span class="sd">def nchoosek(n, k):</span>
<span class="sd">    numerator = factorial(n)</span>
<span class="sd">    denominator = factorial(k) * factorial(n - k)</span>
<span class="sd">    return (1.0 * numerator) / (1.0 * denominator)</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018 by Effective Quadratures.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'v7.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>